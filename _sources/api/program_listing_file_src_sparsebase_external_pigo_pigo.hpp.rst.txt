
.. _program_listing_file_src_sparsebase_external_pigo_pigo.hpp:

Program Listing for File pigo.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_sparsebase_external_pigo_pigo.hpp>` (``src/sparsebase/external/pigo/pigo.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef PIGO_HPP
   #define PIGO_HPP
   
   #include <algorithm>
   #include <atomic>
   #include <cmath>
   #include <cstring>
   #include <fcntl.h>
   #include <memory>
   #include <omp.h>
   #include <stdexcept>
   #include <stdlib.h>
   #include <string>
   #include <sys/mman.h>
   #include <sys/stat.h>
   #include <sys/types.h>
   #include <type_traits>
   #include <unistd.h>
   #include <vector>
   
   namespace pigo {
       class Error : public ::std::runtime_error {
           public:
               template<class T>
               Error(T t) : ::std::runtime_error(t) { }
       };
   
       class NotYetImplemented : public Error {
           public:
               template<class T>
               NotYetImplemented(T t) : Error(t) { }
       };
   
       template <typename T> struct is_vector:std::false_type{};
       template <typename... Args> struct is_vector<std::vector<Args...>>:std::true_type{};
   
       template <typename T> struct is_sptr:std::false_type{};
       template <typename... Args> struct is_sptr<std::shared_ptr<Args...>>:std::true_type{};
   
       typedef const char* FilePos;
       typedef char* WFilePos;
   
       class FileReader {
           private:
               FilePos end;
           public:
               FilePos d;
   
               FileReader(FilePos d, FilePos end) :
                   end(end), d(d) { }
   
               void skip_comments();
   
               template<typename T>
               T read_int();
   
               template<typename T>
               T read_fp();
   
               template<typename T>
               T read_sign() {
                   if (*d == '-') return (T)(-1);
                   return (T)1;
               }
   
               bool at_end_of_line();
   
               void move_to_non_int();
   
               void move_to_non_fp();
   
               void move_to_fp();
   
               void move_to_first_int();
   
               void move_to_next_int();
   
               void move_to_next_signed_int();
   
               void move_to_next_int_or_nl();
   
               void move_to_eol();
   
               FileReader operator+(size_t s) {
                   FileReader n {d, end};
                   n.d = d + s;
                   n.end = end;
                   if (n.d > end) n.d = end;
                   return n;
               }
               FileReader& operator+=(size_t s) {
                   d += s;
                   if (d > end) d = end;
                   return *this;
               }
   
               void smaller_end(FileReader &rhs) {
                   if (rhs.d < end) end = rhs.d;
               }
   
               bool good() { return d < end; }
   
               size_t size() { return end - d; }
   
               bool at_str(std::string s);
   
               char peek() {
                   if (d == end) return 0;
                   return *d;
               }
   
               bool at_nl_or_eol() {
                   if (d == end) return true;
                   return (*d == '\n' || *d == '%' || *d == '#');
               }
   
               bool at_zero() {
                   if (d >= end+1) return false;
                   if (*d != '0') return false;
                   if (*(d+1) >= '0' && *(d+1) <= '9') return false;
                   return true;
               }
       };
   
       enum FileType {
           MATRIX_MARKET,
           EDGE_LIST,
           PIGO_COO_BIN,
           PIGO_CSR_BIN,
           PIGO_DIGRAPH_BIN,
           GRAPH,
           AUTO
       };
   
       enum OpenMode {
           READ,
           WRITE
       };
   
       class File {
           protected:
               char* data_;
               size_t size_;
               FilePos fp_;
               std::string fn_;
           public:
               File(std::string fn, OpenMode mode, size_t max_size=0);
   
               ~File() noexcept;
   
               File(const File&) = delete;
   
               File& operator=(const File&) = delete;
   
               File(File &&o) {
                   data_ = o.data_;
                   size_ = o.size_;
               }
   
               File& operator=(File&& o);
   
               FilePos fp() { return fp_; }
   
               void seek(size_t pos);
   
               template<class T> T read();
   
               void read(const std::string& s);
   
               template<class T> void write(T val);
   
               void parallel_write(char* v, size_t v_size);
   
               void parallel_read(char* v, size_t v_size);
   
               size_t size() { return size_; }
   
               FileType guess_file_type();
   
               FileReader reader() {
                   return FileReader {fp_, data_+size_};
               }
       };
       class ROFile : public File {
           public:
               ROFile(std::string fn) : File(fn, READ) { }
       };
       class WFile : public File {
           public:
               WFile(std::string fn, size_t max_size) :
                   File(fn, WRITE, max_size) { }
       };
   
       template<class T> T read(FilePos &fp);
   
       template<class T> void write(FilePos &fp, T val);
   
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type = false,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type = false
           > inline size_t write_size(T obj);
       template<typename T,
           typename std::enable_if<std::is_integral<T>::value, bool>::type = true,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type = false
           > inline size_t write_size(T obj);
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type = false,
           typename std::enable_if<std::is_floating_point<T>::value, bool>::type = true
           > inline size_t write_size(T obj);
   
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type = false,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type = false
           > inline void write_ascii(FilePos &fp, T obj);
       template<typename T,
           typename std::enable_if<std::is_integral<T>::value, bool>::type = true,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type = false
           > inline void write_ascii(FilePos &fp, T obj);
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type = false,
           typename std::enable_if<std::is_floating_point<T>::value, bool>::type = true
           > inline void write_ascii(FilePos &fp, T obj);
   
       namespace detail {
   
           template<bool do_alloc, typename T, bool ptr_flag, bool vec_flag, bool sptr_flag>
           struct allocate_impl_ {
               static void op_(T&, size_t) {
                   throw Error("Invalid allocation strategy");
               }
           };
   
           template<typename T, bool ptr_flag, bool vec_flag, bool sptr_flag>
           struct allocate_impl_<false, T, ptr_flag, vec_flag, sptr_flag> {
               static void op_(T&, size_t) { }
           };
   
           template<typename T>
           struct allocate_impl_<true, T, true, false, false> {
               static void op_(T& it, size_t nmemb) {
                   it = static_cast<T>(malloc(sizeof(*(T){nullptr})*nmemb));
                   if (it == NULL)
                       throw Error("Unable to allocate");
               }
           };
   
           template<typename T>
           struct allocate_impl_<true, T, false, true, false> {
               static void op_(T& it, size_t nmemb) {
                   it.resize(nmemb);
               }
           };
   
           template<typename T>
           struct allocate_impl_<true, T, false, false, true> {
               static void op_(T& it, size_t nmemb) {
                   it = std::shared_ptr<typename T::element_type>(
                           new typename T::element_type[nmemb],
                           std::default_delete<typename T::element_type []>()
                           );
               }
           };
   
           template<class T, bool do_alloc=true>
           inline
           void allocate_mem_(T& it, size_t nmemb) {
               // Use the appropriate allocation strategy
               allocate_impl_<do_alloc, T,
                   std::is_pointer<T>::value,
                   is_vector<T>::value,
                   is_sptr<T>::value
               >::op_(it, nmemb);
           }
   
           template<bool do_free, typename T, bool ptr_flag, bool vec_flag, bool sptr_flag>
           struct free_impl_ {
               static void op_(T&) { };
           };
   
           template<typename T>
           struct free_impl_<true, T, true, false, false> {
               static void op_(T& it) {
                   free(it);
               }
           };
   
           template<typename T>
           struct free_impl_<true, T, false, true, false> {
               static void op_(T&) { }
           };
   
           template<typename T>
           struct free_impl_<true, T, false, false, true> {
               static void op_(T&) { }
           };
   
           template<class T, bool do_free=true>
           inline
           void free_mem_(T& it) {
               // Use the appropriate allocation strategy
               free_impl_<do_free, T,
                   std::is_pointer<T>::value,
                   is_vector<T>::value,
                   is_sptr<T>::value
               >::op_(it);
           }
   
           template<typename T, bool ptr_flag, bool vec_flag, bool sptr_flag>
           struct get_raw_data_impl_;
   
           template<typename T>
           struct get_raw_data_impl_<T, true, false, false> {
               static char* op_(T& v) { return (char*)(v); }
           };
   
           template<typename T>
           struct get_raw_data_impl_<T, false, true, false> {
               static char* op_(T& v) { return (char*)(v.data()); }
           };
   
           template<typename T>
           struct get_raw_data_impl_<T, false, false, true> {
               static char* op_(T& v) { return (char*)(v.get()); }
           };
   
           template<class T>
           inline
           char* get_raw_data_(T& v) {
               return get_raw_data_impl_<T,
                   std::is_pointer<T>::value,
                   is_vector<T>::value,
                   is_sptr<T>::value
               >::op_(v);
           }
   
           template<class S, class T, bool ptr_flag, bool vec_flag, bool sptr_flag>
           struct set_value_impl_;
   
           template<class S, class T>
           struct set_value_impl_<S, T, true, false, false> {
               static void op_(S &space, size_t offset, T val) {
                   space[offset] = val;
               }
           };
   
           template<class S, class T>
           struct set_value_impl_<S, T, false, true, false> {
               static void op_(S &space, size_t offset, T val) {
                   space[offset] = val;
               }
           };
   
           template<class S, class T>
           struct set_value_impl_<S, T, false, false, true> {
               static void op_(S &space, size_t offset, T val) {
                   space.get()[offset] = val;
               }
           };
   
           template<class S, class T>
           inline
           void set_value_(S &space, size_t offset, T val) {
               // Use the appropriate strategy based on the space type
               set_value_impl_<S, T,
                   std::is_pointer<S>::value,
                   is_vector<S>::value,
                   is_sptr<S>::value
               >::op_(space, offset, val);
           }
   
           template<class S, class T, bool ptr_flag, bool vec_flag, bool sptr_flag>
           struct get_value_impl_;
   
           template<class S, class T>
           struct get_value_impl_<S, T, true, false, false> {
               static T op_(S &space, size_t offset) {
                   return space[offset];
               }
           };
   
           template<class S, class T>
           struct get_value_impl_<S, T, false, true, false> {
               static T op_(S &space, size_t offset) {
                   return space[offset];
               }
           };
   
           template<class S, class T>
           struct get_value_impl_<S, T, false, false, true> {
               static T op_(S &space, size_t offset) {
                   return space.get()[offset];
               }
           };
   
           template<class S, class T>
           inline
           T get_value_(S &space, size_t offset) {
               // Use the appropriate strategy based on the space type
               return get_value_impl_<S, T,
                   std::is_pointer<S>::value,
                   is_vector<S>::value,
                   is_sptr<S>::value
               >::op_(space, offset);
           }
   
           template <bool B>
           struct if_true_i_ {
               static bool op_() { return false; }
           };
           template <>
           struct if_true_i_<true> {
               static bool op_() { return true; }
           };
           template <bool B>
           bool if_true_() {
               return if_true_i_<B>::op_();
           }
   
       }
   
       void parallel_write(FilePos &fp, char* v, size_t v_size);
   
       void parallel_read(FilePos &fp, char* v, size_t v_size);
   
   
       // We include the prototype here to support converting from CSR
       template<class Label, class Ordinal, class LabelStorage, class OrdinalStorage, bool weighted, class Weight, class WeightStorage>
       class CSR;
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class Storage=Label*,
           bool symmetric=false,
           bool keep_upper_triangle_only=false,
           bool remove_self_loops=false,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class COO {
           private:
               Storage x_;
   
               Storage y_;
   
               WeightStorage w_;
   
               Label n_;
   
               Label nrows_;
   
               Label ncols_;
   
               Ordinal m_;
   
               void read_(File& f, FileType ft);
   
               void read_el_(FileReader& r);
   
               void read_mm_(FileReader& r);
   
               void read_bin_(File& f);
   
               void allocate_();
   
               template <class CL, class CO, class LStorage, class OStorage, class CW, class CWS>
               void convert_csr_(CSR<CL, CO, LStorage, OStorage, weighted, CW, CWS>& csr);
   
               template <bool count_only>
               void read_coord_entry_(size_t &coord_pos, FileReader &r,
                       Label &max_row, Label &max_col);
   
               void copy_(const COO& other) {
                   #pragma omp parallel for
                   for (Ordinal pos = 0; pos < m_; ++pos) {
                       Label x_val = detail::get_value_<
                                   Storage,
                                   Label
                               >((Storage&)(other.x_), pos);
                       detail::set_value_(x_, pos, x_val);
                       Label y_val = detail::get_value_<
                                   Storage,
                                   Label
                               >((Storage&)(other.y_), pos);
                       detail::set_value_(y_, pos, y_val);
                   }
                   if (detail::if_true_<weighted>()) {
                       #pragma omp parallel for
                       for (Ordinal pos = 0; pos < m_; ++pos) {
                           Weight w_val = detail::get_value_<
                                       WeightStorage,
                                       Weight
                                   >((WeightStorage&)(other.w_), pos);
                           detail::set_value_(w_, pos, w_val);
                       }
                   }
               }
           public:
               COO(std::string fn);
   
               COO(std::string fn, FileType ft);
   
               COO(File& f, FileType ft);
   
               template<class CL, class CO, typename LabelStorage, typename OrdinalStorage, class CW, class CWS>
               COO(CSR<CL, CO, LabelStorage, OrdinalStorage, weighted, CW, CWS>& csr);
   
               COO() : n_(0), nrows_(0), ncols_(0), m_(0) { }
   
               COO(Label n, Label nrows, Label ncols, Ordinal m) :
                       n_(n), nrows_(nrows), ncols_(ncols), m_(m) {
                   allocate_();
               }
   
               Storage& x() { return x_; }
   
               Storage& y() { return y_; }
   
               WeightStorage& w() { return w_; }
   
               Ordinal m() const { return m_; }
   
               Label n() const { return n_; }
   
               void set_n(Label new_n) { n_ = new_n; }
   
               void set_nrows(Label new_nrows) { nrows_ = new_nrows; }
   
               void set_ncols(Label new_ncols) { ncols_ = new_ncols; }
   
               Label nrows() const { return nrows_; }
   
               Label ncols() const { return ncols_; }
   
               void save(std::string fn);
   
               void write(std::string fn);
   
               void free() {
                   if (m_ > 0) {
                       detail::free_mem_(x_);
                       detail::free_mem_(y_);
                       detail::free_mem_<WeightStorage, weighted>(w_);
                       m_ = 0;
                   }
               }
   
               COO(const COO& other) : n_(other.n_), nrows_(other.nrows_),
                       ncols_(other.ncols_), m_(other.m_) {
                   allocate_();
                   copy_(other);
               }
   
               COO& operator=(const COO& other) {
                   if (&other != this) {
                       free();
                       n_ = other.n_;
                       nrows_ = other.nrows_;
                       ncols_ = other.ncols_;
                       m_ = other.m_;
                       allocate_();
                       copy_(other);
                   }
   
                   return *this;
               }
   
               COO& transpose() {
                   std::swap(x_, y_);
                   return *this;
               }
   
               static constexpr const char* coo_file_header = "PIGO-COO-v1";
       };
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class Storage=Label*,
           class Weight=float,
           class WeightStorage=Weight*,
           bool symmetric=false,
           bool keep_upper_triangle_only=false,
           bool remove_self_loops=false
       >
       using WCOO = COO<Label, Ordinal, Storage,
           symmetric, keep_upper_triangle_only, remove_self_loops,
           true, Weight, WeightStorage>;
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class Weight=float,
           bool symmetric=false,
           bool keep_upper_triangle_only=false,
           bool remove_self_loops=false
       >
       using WCOOPtr = COO<
           Label,
           Ordinal,
           Label*,
           symmetric,
           keep_upper_triangle_only,
           remove_self_loops,
           true,
           Weight,
           Weight*>;
   
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class LabelStorage=Label*,
           class OrdinalStorage=Ordinal*,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class CSR {
           protected:
               LabelStorage endpoints_;
   
               OrdinalStorage offsets_;
   
               WeightStorage weights_;
   
           private:
               Label n_;
   
               Ordinal m_;
   
               Label nrows_;
   
               Label ncols_;
   
               void read_(File& f, FileType ft);
   
               void read_bin_(File& f);
   
               void read_graph_(FileReader& r);
   
               void allocate_();
   
               template <class COOLabel, class COOOrdinal, class COOStorage,
                        bool COOsym, bool COOut, bool COOsl,
                        class COOW, class COOWS>
               void convert_coo_(COO<COOLabel, COOOrdinal, COOStorage,
                       COOsym, COOut, COOsl, weighted, COOW, COOWS>&
                       coo);
           public:
               CSR() : n_(0), m_(0), nrows_(0), ncols_(0) { }
   
               CSR(Label n, Ordinal m, Label nrows, Label ncols) :
                       n_(n), m_(m), nrows_(nrows), ncols_(ncols) {
                   allocate_();
               }
   
               template <class COOLabel, class COOOrdinal, class COOStorage,
                        bool COOsym, bool COOut, bool COOsl,
                        class COOW, class COOWS>
               CSR(COO<COOLabel, COOOrdinal, COOStorage, COOsym, COOut,
                       COOsl, weighted, COOW, COOWS>& coo);
   
               CSR(std::string fn);
   
               CSR(std::string fn, FileType ft);
   
               CSR(File& f, FileType ft);
   
               LabelStorage& endpoints() { return endpoints_; }
   
               OrdinalStorage& offsets() { return offsets_; }
   
               WeightStorage& weights() { return weights_; }
   
               Ordinal m() const { return m_; }
   
               Label n() const { return n_; }
   
               Label nrows() const { return nrows_; }
   
               Label ncols() const { return ncols_; }
   
               void sort();
   
               template<class nL=Label, class nO=Ordinal, class nLS=LabelStorage, class nOS=OrdinalStorage, bool nw=weighted, class nW=Weight, class nWS=WeightStorage>
               CSR<nL, nO, nLS, nOS, nw, nW, nWS> new_csr_without_dups();
   
               void free() {
                   detail::free_mem_(endpoints_);
                   detail::free_mem_(offsets_);
                   detail::free_mem_<WeightStorage, weighted>(weights_);
               }
   
               size_t save_size () const;
   
               void save(std::string fn);
   
               void save(File& w);
   
               static constexpr const char* csr_file_header = "PIGO-CSR-v2";
       };
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class Weight=float
       >
       using WCSRPtr = CSR<
           Label,
           Ordinal,
           Label*,
           Ordinal*,
           true,
           Weight,
           Weight*>;
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class LabelStorage=Label*,
           class OrdinalStorage=Ordinal*,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class CSC : public CSR<
                   Label,
                   Ordinal,
                   LabelStorage,
                   OrdinalStorage,
                   weighted,
                   Weight,
                   WeightStorage
               > {
           public:
               using CSR<
                   Label,
                   Ordinal,
                   LabelStorage,
                   OrdinalStorage,
                   weighted,
                   Weight,
                   WeightStorage
               >::CSR;
       };
   
   
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class LabelStorage=Label*,
           class OrdinalStorage=Ordinal*,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class SymMatrix: public CSR<
                           Label,
                           Ordinal,
                           LabelStorage,
                           OrdinalStorage,
                           weighted,
                           Weight,
                           WeightStorage
                        > {
           public:
               using CSR<
                       Label,
                       Ordinal,
                       LabelStorage,
                       OrdinalStorage,
                       weighted,
                       Weight,
                       WeightStorage
                   >::CSR;
       };
   
       template<
           class Label=uint32_t,
           class Ordinal=Label,
           class LabelStorage=Label*,
           class OrdinalStorage=Ordinal*,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class Matrix {
           private:
               CSR<
                       Label,
                       Ordinal,
                       LabelStorage,
                       OrdinalStorage,
                       weighted,
                       Weight,
                       WeightStorage
                   > csr_;
   
               CSC<
                       Label,
                       Ordinal,
                       LabelStorage,
                       OrdinalStorage,
                       weighted,
                       Weight,
                       WeightStorage
                   > csc_;
   
               template <class COOLabel, class COOOrdinal, class COOStorage,
                        bool COOsym, bool COOut, bool COOsl,
                        class COOW, class COOWS>
               void from_coo_(COO<COOLabel, COOOrdinal, COOStorage, COOsym, COOut,
                       COOsl, weighted, COOW, COOWS>& coo) {
                   auto coo_copy = coo;
                   coo_copy.transpose();
   
                   csc_ = CSC<
                               Label,
                               Ordinal,
                               LabelStorage,
                               OrdinalStorage,
                               weighted,
                               Weight,
                               WeightStorage
                           > { coo_copy };
                   coo_copy.free();
   
                   csr_ = CSR<
                               Label,
                               Ordinal,
                               LabelStorage,
                               OrdinalStorage,
                               weighted,
                               Weight,
                               WeightStorage
                           > { coo };
               }
   
           public:
               template <class COOLabel, class COOOrdinal, class COOStorage,
                        bool COOsym, bool COOut, bool COOsl,
                        class COOW, class COOWS>
               Matrix(COO<COOLabel, COOOrdinal, COOStorage, COOsym, COOut,
                       COOsl, weighted, COOW, COOWS>& coo) {
                   from_coo_(coo);
               }
   
               Matrix(std::string filename) {
                   COO<
                       Label, Ordinal, LabelStorage,
                       false, false, false,
                       weighted, Weight, WeightStorage
                   > coo {filename};
                   from_coo_(coo);
                   coo.free();
               }
   
               void free() {
                   csc_.free();
                   csr_.free();
               }
   
               Ordinal nrows() { return csr_.nrows(); }
   
               Ordinal ncols() { return csr_.ncols(); }
   
               CSR<
                   Label,
                   Ordinal,
                   LabelStorage,
                   OrdinalStorage,
                   weighted,
                   Weight,
                   WeightStorage
               >& csr() { return csr_; }
   
               CSC<
                   Label,
                   Ordinal,
                   LabelStorage,
                   OrdinalStorage,
                   weighted,
                   Weight,
                   WeightStorage
               >& csc() { return csc_; }
   
       };
   
       template<class V, class O, class S>
       class EdgeItT {
           private:
               O pos;
               S s;
           public:
               EdgeItT(S s, O pos) : pos(pos), s(s) { }
               bool operator!=(EdgeItT& rhs) { return pos != rhs.pos; }
               V& operator*();
               void operator++() { ++pos; }
       };
   
       template<class V, class O, class S>
       class EdgeIt {
           private:
               O begin_;
               O end_;
               S s;
           public:
               EdgeIt(O begin, O end, S s) : begin_(begin),
                       end_(end), s(s) { }
   
               EdgeItT<V,O,S> begin() { return EdgeItT<V,O,S> {s, begin_}; }
               EdgeItT<V,O,S> end() { return EdgeItT<V,O,S> {s, end_}; }
       };
   
   
       template<
           class vertex_t=uint32_t,
           class edge_ctr_t=uint32_t,
           class edge_storage=vertex_t*,
           class edge_ctr_storage=edge_ctr_t*,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class BaseGraph : public CSR<
                           vertex_t,
                           edge_ctr_t,
                           edge_storage,
                           edge_ctr_storage,
                           weighted,
                           Weight,
                           WeightStorage
                       > {
           public:
               using CSR<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage,
                     weighted, Weight, WeightStorage>::CSR;
   
               edge_ctr_t neighbor_start(vertex_t v);
   
               edge_ctr_t neighbor_end(vertex_t v);
   
               edge_ctr_t degree(vertex_t v) {
                   return neighbor_end(v)-neighbor_start(v);
               }
   
               EdgeIt<vertex_t, edge_ctr_t, edge_storage> neighbors(vertex_t v) {
                   return EdgeIt<vertex_t, edge_ctr_t, edge_storage> {neighbor_start(v),
                       neighbor_end(v), this->endpoints_};
               }
       };
   
       using Graph = BaseGraph<>;
   
       using BigGraph = BaseGraph<uint64_t, uint64_t>;
   
       template<
           class vertex_t=uint32_t,
           class edge_ctr_t=uint32_t,
           class edge_storage=vertex_t*,
           class edge_ctr_storage=edge_ctr_t*,
           bool weighted=false,
           class Weight=float,
           class WeightStorage=Weight*
       >
       class DiGraph {
           private:
               BaseGraph<
                       vertex_t,
                       edge_ctr_t,
                       edge_storage,
                       edge_ctr_storage,
                       weighted,
                       Weight,
                       WeightStorage
                   > in_;
   
               BaseGraph<
                       vertex_t,
                       edge_ctr_t,
                       edge_storage,
                       edge_ctr_storage,
                       weighted,
                       Weight,
                       WeightStorage
                   > out_;
   
               void read_(File& f, FileType ft);
   
               template <class COOvertex_t, class COOedge_ctr_t, class COOStorage,
                        bool COOsym, bool COOut, bool COOsl,
                        class COOW, class COOWS>
               void from_coo_(COO<COOvertex_t, COOedge_ctr_t, COOStorage, COOsym, COOut,
                       COOsl, weighted, COOW, COOWS>& coo) {
                   auto coo_copy = coo;
                   coo_copy.transpose();
   
                   in_ = BaseGraph<
                               vertex_t,
                               edge_ctr_t,
                               edge_storage,
                               edge_ctr_storage,
                               weighted,
                               Weight,
                               WeightStorage
                           > { coo_copy };
                   coo_copy.free();
   
                   out_ = BaseGraph<
                               vertex_t,
                               edge_ctr_t,
                               edge_storage,
                               edge_ctr_storage,
                               weighted,
                               Weight,
                               WeightStorage
                           > { coo };
               }
   
   
           public:
               template <class COOvertex_t, class COOedge_ctr_t, class COOStorage,
                        bool COOsym, bool COOut, bool COOsl,
                        class COOW, class COOWS>
               DiGraph(COO<COOvertex_t, COOedge_ctr_t, COOStorage, COOsym, COOut,
                       COOsl, weighted, COOW, COOWS>& coo) {
                   from_coo_(coo);
               }
   
               DiGraph(std::string fn);
   
               DiGraph(std::string fn, FileType ft);
   
               DiGraph(File& f, FileType ft);
   
               void free() {
                   in_.free();
                   out_.free();
               }
   
               edge_ctr_t m() { return out_.m(); }
   
               edge_ctr_t n() { return out_.n(); }
   
               edge_ctr_t nrows() { return out_.nrows(); }
   
               edge_ctr_t ncols() { return out_.ncols(); }
   
               BaseGraph<
                   vertex_t,
                   edge_ctr_t,
                   edge_storage,
                   edge_ctr_storage,
                   weighted,
                   Weight,
                   WeightStorage
               >& out() { return out_; }
   
               BaseGraph<
                   vertex_t,
                   edge_ctr_t,
                   edge_storage,
                   edge_ctr_storage,
                   weighted,
                   Weight,
                   WeightStorage
               >& in() { return in_; }
   
               void save(std::string fn);
   
               static constexpr const char* digraph_file_header = "PIGO-DiGraph-v1";
       };
   
       inline
       File::File(std::string fn, OpenMode mode, size_t max_size) :
                   fn_(fn) {
           int open_mode = O_RDONLY;
           int prot = PROT_READ;
           char fopen_mode[] = "rb";
           if (mode == WRITE) {
               open_mode = O_RDWR;
               prot = PROT_WRITE | PROT_READ;
               fopen_mode[1] = '+';
               if (max_size == 0)
                   throw Error("max_size is too low to write");
           } else if (max_size > 0)
               throw Error("Max_size is only used for writing");
   
           if (mode == WRITE) {
               // Set the file to the given size
               FILE *w_f = fopen(fn.c_str(), "w");
               if (w_f == NULL) throw Error("PIGO: Unable to open file for writing");
               if (fseeko(w_f, max_size-1, SEEK_SET) != 0) throw Error("PIGO: Seek to set size");
               if (fputc(1, w_f) != 1) throw Error("PIGO: Unable to set size");
               if (fclose(w_f) != 0) throw Error("PIGO: Unable to close new file");
           }
   
           // Open the file to get the total size and base the mmap on
           #ifdef __linux__
           int fd = open(fn.c_str(), open_mode | O_DIRECT);
           #else
           int fd = open(fn.c_str(), open_mode);
           #ifdef __APPLE__
           fcntl(fd, F_NOCACHE, 1);
           #endif
           #endif
           if (fd < 0) throw Error("Unable to open file");
           FILE *f = fdopen(fd, fopen_mode);
           if (f == NULL) throw Error("PIGO: fdopen file");
   
           // Find the file size
           if (fseeko(f, 0 , SEEK_END) != 0)  throw Error("PIGO: Unable to seek to end");
           size_ = ftello(f);
           if (size_ == (size_t)(-1)) throw Error("PIGO: Invalid size");
   
           if (mode == WRITE && size_ != max_size)
               throw Error("PIGO: Wrong file size of new file");
   
           // MMAP the space
           data_ = (char*)mmap(NULL, size_*sizeof(char), prot,
                   MAP_SHARED | MAP_NORESERVE, fd, 0);
           if (data_ == MAP_FAILED) throw Error("PIGO: MMAP");
           if (fclose(f) != 0) throw Error("PIGO: Fclose");
   
           // Advise the mmap for performance
           if (madvise(data_, size_, MADV_WILLNEED) != 0) throw Error("PIGO: madvise");
   
           // Finally, set the file position
           seek(0);
       }
   
       inline
       File::~File() noexcept {
           if (data_) {
               munmap(data_, size_);
               data_ = nullptr;
           }
       }
   
       inline
       File& File::operator=(File&& o) {
           if (&o != this) {
               if (data_)
                   munmap(data_, size_);
               data_ = o.data_;
               size_ = o.size_;
               o.data_ = nullptr;
           }
           return *this;
       }
   
       template<class T>
       inline
       T File::read() {
           return ::pigo::read<T>(fp_);
       }
   
       inline
       void File::read(const std::string& s) {
           FileReader r = reader();
           if (!r.at_str(s)) throw Error("Cannot read the given string");
           // Move passed it
           fp_ += s.size();
       }
   
       template<class T>
       inline
       void File::write(T val) {
           return ::pigo::write(fp_, val);
       }
   
       inline
       void File::parallel_write(char* v, size_t v_size) {
           ::pigo::parallel_write(fp_, v, v_size);
       }
   
       inline
       void File::parallel_read(char* v, size_t v_size) {
           ::pigo::parallel_read(fp_, v, v_size);
       }
   
       inline
       void File::seek(size_t pos) {
           if (pos >= size_) throw Error("seeking beyond end of file");
           fp_ = data_ + pos;
       }
   
       inline
       FileType File::guess_file_type() {
           // First, check for a PIGO header
           FileReader r = reader();
           if (r.at_str(COO<>::coo_file_header))
               return PIGO_COO_BIN;
           if (r.at_str(CSR<>::csr_file_header))
               return PIGO_CSR_BIN;
           if (r.at_str(DiGraph<>::digraph_file_header))
               return PIGO_DIGRAPH_BIN;
           if (r.at_str("PIGO"))
               throw Error("Unsupported PIGO binary format, likely version mismatch");
           // Check the filename for .mtx
           std::string ext_mtx { ".mtx" };
           if (fn_.size() >= ext_mtx.size() &&
                   fn_.compare(fn_.size() - ext_mtx.size(), ext_mtx.size(), ext_mtx) == 0)
               return MATRIX_MARKET;
   
           std::string ext_g { ".graph" };
           if (fn_.size() >= ext_g.size() &&
                   fn_.compare(fn_.size() - ext_g.size(), ext_g.size(), ext_g) == 0)
               return GRAPH;
           // In future version, we can add a simple CSR-like file check by
           // looking at a few lines and counting elements
           // Default to an edge list
           return EDGE_LIST;
       };
   
       template<class T>
       inline
       T read(FilePos &fp) {
           T res = *(T*)fp;
           fp += sizeof(T);
           return res;
       }
   
       template<class T>
       inline
       void write(FilePos &fp, T val) {
           *(T*)fp = val;
           fp += sizeof(T);
       }
   
       template<>
       inline
       void write(FilePos &fp, std::string val) {
           for (char x : val) {
               write(fp, x);
           }
       }
   
       namespace detail {
           template<typename T, typename std::enable_if<!std::is_signed<T>::value, bool>::type = false>
           inline
           size_t neg_size(T obj) {
               (void)obj;
               return 0;
           }
   
           template<typename T, typename std::enable_if<std::is_signed<T>::value, bool>::type = true>
           inline
           size_t neg_size(T obj) {
               if (obj < 0) return 1;
               return 0;
           }
   
           template<typename T, typename std::enable_if<!std::is_signed<T>::value, bool>::type = false>
           inline
           void write_neg_ascii(FilePos &fp, T obj) {
               (void)fp;
               (void)obj;
           }
   
           template<typename T, typename std::enable_if<std::is_signed<T>::value, bool>::type = true>
           inline
           void write_neg_ascii(FilePos &fp, T obj) {
               if (obj < 0) pigo::write(fp, '-');
           }
   
           template<typename T, typename std::enable_if<!std::is_signed<T>::value, bool>::type = false>
           inline
           T get_positive(T obj) {
               return obj;
           }
           template<typename T, typename std::enable_if<std::is_signed<T>::value, bool>::type = true>
           inline
           T get_positive(T obj) {
               if (obj < 0) return -obj;
               return obj;
           }
       }
   
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type
           >
       inline
       size_t write_size(T obj) {
           // We do not have special processing for this obj
           return std::to_string(obj).size();
       }
   
       template<typename T,
           typename std::enable_if<std::is_integral<T>::value, bool>::type,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type
           >
       inline
       size_t write_size(T obj) {
           // If it is signed, and negative, it will take an additional char
           size_t res = detail::neg_size(obj);
           do {
               obj /= 10;
               ++res;
           } while (obj != 0);
           return res;
       }
   
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type,
           typename std::enable_if<std::is_floating_point<T>::value, bool>::type
           >
       inline
       size_t write_size(T obj) {
           // This can be optimized significantly by manually writing
           return std::to_string(obj).size();
       }
   
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type
           >
       inline
       void write_ascii(FilePos &fp, T obj) {
           // We do not have special processing for this obj
           write(fp, std::to_string(obj));
       }
   
       template<typename T,
           typename std::enable_if<std::is_integral<T>::value, bool>::type,
           typename std::enable_if<!std::is_floating_point<T>::value, bool>::type
           >
       inline
       void write_ascii(FilePos &fp, T obj) {
           detail::write_neg_ascii(fp, obj);
           obj = detail::get_positive(obj);
   
           size_t num_size = write_size(obj);
           size_t pos = num_size-1;
           // Write out each digit
           do {
               *((char*)fp+pos--) = (obj%10)+'0';
               obj /= 10;
           } while (obj != 0);
           fp += num_size;
       }
   
       template<typename T,
           typename std::enable_if<!std::is_integral<T>::value, bool>::type,
           typename std::enable_if<std::is_floating_point<T>::value, bool>::type
           >
       inline
       void write_ascii(FilePos &fp, T obj) {
           write(fp, std::to_string(obj));
       }
   
       inline
       void FileReader::skip_comments() {
           while (d < end && (*d == '%' || *d == '#'))
               while (d < end && (*d++ != '\n')) { }
       }
   
       template<typename T>
       inline
       T FileReader::read_int() {
           T res = 0;
           while (d < end && (*d < '0' || *d > '9')) ++d;
   
           // Read out digit by digit
           while (d < end && (*d >= '0' && *d <= '9')) {
               res = res*10 + (*d-'0');
               ++d;
           }
           return res;
       }
   
       template<typename T>
       inline
       T FileReader::read_fp() {
           T res = 0.0;
           while (d < end && !((*d >= '0' && *d <= '9') || *d == 'e' ||
                       *d == 'E' || *d == '-' || *d == '+' || *d == '.')) ++d;
           // Read the size
           bool positive = true;
           if (*d == '-') {
               positive = false;
               ++d;
           } else if (*d == '+') ++d;
   
           // Support a simple form of floating point integers
           // Note: this is not the most accurate or fastest strategy
           // (+-)AAA.BBB(eE)(+-)ZZ.YY
           // Read the 'A' part
           while (d < end && (*d >= '0' && *d <= '9')) {
               res = res*10. + (T)(*d-'0');
               ++d;
           }
           if (*d == '.') {
               ++d;
               T fraction = 0.;
               size_t fraction_count = 0;
               // Read the 'B' part
               while (d < end && (*d >= '0' && *d <= '9')) {
                   fraction = fraction*10. + (T)(*d-'0');
                   ++d;
                   ++fraction_count;
               }
               res += fraction / std::pow(10., fraction_count);
           }
           if (*d == 'e' || *d == 'E') {
               ++d;
               T exp = read_fp<T>();
               res *= std::pow(10., exp);
           }
   
           if (!positive) res *= -1;
           return res;
       }
   
       inline
       bool FileReader::at_end_of_line() {
           FilePos td = d;
           while (td < end && *td != '\n') {
               if (*td != ' ' && *td != '\r')
                   return false;
               ++td;
           }
           return true;
       }
   
       inline
       void FileReader::move_to_non_int() {
           while (d < end && (*d >= '0' && *d <= '9')) ++d;
       }
   
       inline
       void FileReader::move_to_non_fp() {
           while (d < end && ((*d >= '0' && *d <= '9') || *d == 'e' ||
                       *d == 'E' || *d == '-' || *d == '+' || *d == '.')) ++d;
       }
   
       inline
       void FileReader::move_to_fp() {
           while (d < end && !((*d >= '0' && *d <= '9') || *d == 'e' ||
                       *d == 'E' || *d == '-' || *d == '+' || *d == '.')) ++d;
       }
   
       inline
       void FileReader::move_to_first_int() {
           // Move through the non-ints and comments
           if (*d == '%' || *d == '#') skip_comments();
           while (d < end && (*d < '0' || *d > '9')) {
               ++d;
               if (*d == '%' || *d == '#') skip_comments();
           }
       }
   
       inline
       void FileReader::move_to_next_int() {
           // Move through the current int
           move_to_non_int();
   
           // Move through the non-ints to the next int
           move_to_first_int();
       }
   
       inline
       void FileReader::move_to_next_signed_int() {
           if (*d == '+' || *d == '-') ++d;
           move_to_non_int();
   
           // Move to the next integer or signed integral value
           if (*d == '%' || *d == '#') skip_comments();
           while (d < end && (*d < '0' || *d > '9') && *d != '+' && *d != '-') {
               ++d;
               if (*d == '%' || *d == '#') skip_comments();
           }
       }
   
       inline
       void FileReader::move_to_next_int_or_nl() {
           bool at_int = false;
           if (d < end && (*d >= '0' && *d <= '9')) at_int = true;
           // Move through the current int or newline
           move_to_non_int();
           if (d < end && *d == '\n') {
               if (at_int) return;     // We have now reached a newline
               ++d; // Move through a newline
           }
   
           if (*d == '%' || *d == '#') {
               skip_comments();
               --d;        // This will end at a newline
               return;
           }
           while (d < end && (*d < '0' || *d > '9') && *d != '\n') {
               ++d;
               if (*d == '%' || *d == '#') {
                   skip_comments();
                   --d;
                   return;
               }
           }
       }
   
       inline
       void FileReader::move_to_eol() {
           while (d < end && *d != '\n') { ++d; }
       }
   
       inline
       bool FileReader::at_str(std::string s) {
           // Ensure the size is suitable for comparison
           if (d + s.size() >= end) return false;
           std::string d_str { d, d+s.size() };
           return s.compare(d_str) == 0;
       }
   
       inline
       void parallel_write(FilePos &fp, char* v, size_t v_size) {
           WFilePos wfp = (WFilePos)(fp);
           #pragma omp parallel
           {
               int num_threads = omp_get_num_threads();
               int thread_id = omp_get_thread_num();
   
               size_t my_data = v_size/num_threads;
               // Give the last thread the remaining data
               if (thread_id == num_threads-1)
                   my_data = v_size-my_data*(num_threads-1);
   
               size_t start_pos = (thread_id*(v_size/num_threads));
   
               // Memcpy the region
               char* o_out = (char*)memcpy(wfp + start_pos,
                       v + start_pos, my_data);
               if (o_out != fp+start_pos)
                   throw Error("Unable to write");
           }
           fp += v_size;
       }
   
       inline
       void parallel_read(FilePos &fp, char* v, size_t v_size) {
           #pragma omp parallel
           {
               int num_threads = omp_get_num_threads();
               int thread_id = omp_get_thread_num();
   
               size_t my_data = v_size/num_threads;
               // Give the last thread the remaining data
               if (thread_id == num_threads-1)
                   my_data = v_size-my_data*(num_threads-1);
   
               size_t start_pos = (thread_id*(v_size/num_threads));
   
               // Memcpy the region
               char* o_in = (char*)memcpy(v + start_pos,
                       fp + start_pos, my_data);
               if (o_in != v+start_pos)
                   throw Error("Unable to read");
           }
           fp += v_size;
       }
   
       namespace detail {
           template <bool wgt, class W, class O>
           struct weight_size_i_ {
               static size_t op_(O) { return 0; }
           };
           template <class W, class O>
           struct weight_size_i_<true, W, O> {
               static size_t op_(O m) { return sizeof(W)*m; }
           };
           template <bool wgt, class W, class O>
           size_t weight_size_(O m) {
               return weight_size_i_<wgt, W, O>::op_(m);
           }
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       COO<L,O,S,sym,ut,sl,wgt,W,WS>::COO(std::string fn) : COO(fn, AUTO) { }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       COO<L,O,S,sym,ut,sl,wgt,W,WS>::COO(std::string fn, FileType ft) {
           // Open the file for reading
           ROFile f { fn };
   
           read_(f, ft);
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       COO<L,O,S,sym,ut,sl,wgt,W,WS>::COO(File& f, FileType ft) {
           read_(f, ft);
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::read_(File& f, FileType ft) {
           FileType ft_used = ft;
           // If the file type is AUTO, then try to detect it
           if (ft_used == AUTO) {
               ft_used = f.guess_file_type();
           }
   
           if (ft_used == MATRIX_MARKET) {
               FileReader r = f.reader();
               read_mm_(r);
           } else if (ft_used == EDGE_LIST) {
               FileReader r = f.reader();
               read_el_(r);
           } else if (ft_used == PIGO_COO_BIN) {
               read_bin_(f);
           } else if (ft_used == PIGO_CSR_BIN ||
                   ft_used == GRAPH) {
               // First build a CSR, then convert to a COO
               CSR<L,O,S,S,wgt,W,WS> csr {f, ft_used};
               convert_csr_(csr);
               csr.free();
           } else {
               // We need to first build a CSR, then move back to a COO
               throw NotYetImplemented("Coming in v0.6");
           }
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       template <class CL, class CO, class LS, class OS, class CW, class CWS>
       COO<L,O,S,sym,ut,sl,wgt,W,WS>::COO(CSR<CL,CO,LS,OS,wgt,CW,CWS>& csr) {
           convert_csr_(csr);
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       template <class CL, class CO, class LS, class OS, class CW, class CWS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::convert_csr_(CSR<CL,CO,LS,OS,wgt,CW,CWS>& csr) {
           // First, set our sizes and allocate space
           n_ = csr.n();
           m_ = csr.m();
   
           allocate_();
   
           auto storage_offsets = csr.offsets();
           auto storage_endpoints = csr.endpoints();
           CO* offsets = (CO*)detail::get_raw_data_(storage_offsets);
           CL* endpoints = (CL*)detail::get_raw_data_(storage_endpoints);
   
           CW* weights = nullptr;
           if (detail::if_true_<wgt>()) {
               auto storage_weights = csr.weights();
               weights = (CW*)detail::get_raw_data_(storage_weights);
           }
   
           #pragma omp parallel for schedule(dynamic, 10240)
           for (L v = 0; v < n_; ++v) {
               auto start = endpoints + offsets[v];
               auto end = endpoints + offsets[v+1];
               size_t coo_cur = offsets[v];
               CW* cur_weight = nullptr;
               if (detail::if_true_<wgt>()) {
                   cur_weight = weights + offsets[v];
               }
               for (auto cur = start; cur < end; ++cur, ++coo_cur) {
                   detail::set_value_(x_, coo_cur, v);
                   detail::set_value_(y_, coo_cur, *cur);
   
                   if (detail::if_true_<wgt>()) {
                       detail::set_value_(w_, coo_cur, *cur_weight);
                       ++cur_weight;
                   }
               }
           }
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::allocate_() {
           detail::allocate_mem_<S>(x_, m_);
           detail::allocate_mem_<S>(y_, m_);
           detail::allocate_mem_<WS,wgt>(w_, m_);
       }
   
       namespace detail {
           template <bool wgt, bool is_integral, bool is_signed, bool is_real, class W, class WS, bool counting>
           struct read_wgt_i_ { static inline void op_(size_t&, WS&, FileReader&) {} };
   
           template <class W, class WS>
           struct read_wgt_i_<true, true, true, false, W, WS, true> {
               static inline void op_(size_t&, WS&, FileReader& r) {
                   r.move_to_next_signed_int();
               }
           };
   
           template <class W, class WS>
           struct read_wgt_i_<true, true, false, false, W, WS, true> {
               static inline void op_(size_t&, WS&, FileReader& r) {
                   r.move_to_next_int();
               }
           };
   
           template <class W, class WS>
           struct read_wgt_i_<true, true, true, false, W, WS, false> {
               static inline void op_(size_t& coord_pos, WS& ws, FileReader& r) {
                   r.move_to_next_signed_int();
   
                   W sign = r.read_sign<W>();
                   W val = r.read_int<W>()*sign;
                   set_value_(ws, coord_pos, val);
               }
           };
   
           template <class W, class WS>
           struct read_wgt_i_<true, true, false, false, W, WS, false> {
               static inline void op_(size_t& coord_pos, WS& ws, FileReader& r) {
                   r.move_to_next_int();
   
                   W val = r.read_int<W>();
                   set_value_(ws, coord_pos, val);
               }
           };
   
           template <class W, class WS>
           struct read_wgt_i_<true, false, true, true, W, WS, true> {
               static inline void op_(size_t&, WS&, FileReader& r) {
                   r.move_to_fp();
                   r.move_to_non_fp();
               }
           };
   
           template <class W, class WS>
           struct read_wgt_i_<true, false, true, true, W, WS, false> {
               static inline void op_(size_t& coord_pos, WS& ws, FileReader& r) {
                   r.move_to_fp();
                   // Read the float
                   W val = r.read_fp<W>();
                   set_value_(ws, coord_pos, val);
                   r.move_to_non_fp();
               }
           };
   
           template <bool wgt, class W, class WS, bool counting>
           inline
           void read_wgt_(size_t& coord_pos, WS& ws, FileReader& r) {
               read_wgt_i_<
                   wgt,
                   std::is_integral<W>::value,
                   std::is_signed<W>::value,
                   std::is_floating_point<W>::value,
                   W,
                   WS,
                   counting
               >::op_(coord_pos, ws, r);
           }
   
           template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS, bool count_only>
           struct read_coord_entry_i_;
   
           template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
           struct read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,true> {
               static inline void op_(S& x_, S& y_, WS& w_, size_t &coord_pos, FileReader &r, L& max_row, L& max_col) {
                   L x = r.read_int<L>();
                   r.move_to_next_int();
                   L y = r.read_int<L>();
                   read_wgt_<wgt, W, WS, true>(coord_pos, w_, r);
                   if (!r.good()) return;
                   r.move_to_eol();
                   r.move_to_next_int();
                   if (if_true_<sl>() && x == y) {
                       return read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,true>::op_(x_, y_, w_, coord_pos, r, max_row, max_col);
                   }
                   if (!if_true_<sym>() && if_true_<ut>() && x > y) {
                       return read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,true>::op_(x_, y_, w_, coord_pos, r, max_row, max_col);
                   }
                   if (if_true_<sym>() && !if_true_<ut>() && x != y) ++coord_pos;
                   ++coord_pos;
               }
           };
   
           template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
           struct read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,false> {
               static inline void op_(S& x_, S& y_, WS& w_, size_t &coord_pos, FileReader &r, L& max_row, L& max_col) {
                   L x = r.read_int<L>();
                   r.move_to_next_int();
                   L y = r.read_int<L>();
                   read_wgt_<wgt, W, WS, false>(coord_pos, w_, r);
                   if (!r.good()) return;
                   r.move_to_eol();
                   r.move_to_next_int();
                   if (if_true_<sl>() && x == y) {
                       return read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,false>::op_(x_, y_, w_, coord_pos, r, max_row, max_col);
                   }
                   if (!if_true_<sym>() && if_true_<ut>() && x > y) {
                       return read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,false>::op_(x_, y_, w_, coord_pos, r, max_row, max_col);
                   }
                   if (if_true_<sym>() && if_true_<ut>() && x > y) std::swap(x, y);
                   set_value_(x_, coord_pos, x);
                   set_value_(y_, coord_pos, y);
                   ++coord_pos;
                   if (if_true_<sym>() && !if_true_<ut>() && x != y) {
                       if (if_true_<wgt>()) {
                           auto w = get_value_<WS, W>(w_, coord_pos-1);
                           set_value_(w_, coord_pos, w);
                       }
                       set_value_(y_, coord_pos, x);
                       set_value_(x_, coord_pos, y);
                       ++coord_pos;
                   }
                   if (x > max_row) max_row = x;
                   if (y > max_col) max_col = y;
               }
           };
   
           template<class L, class O, class S, bool wgt, class W, class WS>
           struct read_coord_entry_i_<L,O,S,false,false,false,wgt,W,WS,true> {
               static inline void op_(S&, S&, WS&, size_t &coord_pos, FileReader &r, L&, L&) {
                   r.move_to_next_int();
                   if (!r.good()) return;
                   r.move_to_eol();
                   r.move_to_next_int();
                   ++coord_pos;
               }
           };
   
           template<class L, class O, class S, bool wgt, class W, class WS>
           struct read_coord_entry_i_<L,O,S,false,false,false,wgt,W,WS,false> {
               static inline void op_(S& x_, S& y_, WS& w_, size_t &coord_pos, FileReader &r, L& max_row, L& max_col) {
                   L x = r.read_int<L>();
                   r.move_to_next_int();
                   L y = r.read_int<L>();
                   read_wgt_<wgt, W, WS, false>(coord_pos, w_, r);
                   if (!r.good()) return;
                   r.move_to_eol();
                   r.move_to_next_int();
                   set_value_(x_, coord_pos, x);
                   set_value_(y_, coord_pos, y);
                   ++coord_pos;
                   if (x > max_row) max_row = x;
                   if (y > max_col) max_col = y;
               }
           };
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       template<bool count_only>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::read_coord_entry_(size_t &coord_pos, FileReader &r,
               L& max_row, L& max_col) {
           detail::read_coord_entry_i_<L,O,S,sym,ut,sl,wgt,W,WS,count_only>::op_(x_, y_, w_, coord_pos, r, max_row, max_col);
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::read_mm_(FileReader& r) {
           // Matrix market is ready similar to edge lists, however first the
           // header is skipped
           // Furthermore, any attributes are ignored (symmetric, etc.)
           // This should change in a future PIGO version
           if (!r.at_str("%%MatrixMarket matrix coordinate"))
               throw NotYetImplemented("Unable to handle different MatrixMarket formats");
   
           // Read out the first line
           r.move_to_next_int();
           L nrows = r.read_int<L>()+1;        // account for MM starting at 1
           r.move_to_next_int();
           L ncols = r.read_int<L>()+1;        // account for MM starting at 1
           r.move_to_next_int();
           O nnz = r.read_int<O>();
           r.move_to_eol();
           r.move_to_next_int();
   
           // Now, read out the actual contents
           read_el_(r);
   
           // Finally, sanity check the file
           if (nrows >= nrows_)
               nrows_ = nrows;
           else {
               free();
               throw Error("Too many row labels in file contradicting header");
           }
   
           if (ncols >= ncols_)
               ncols_ = ncols;
           else {
               free();
               throw Error("Too many col labels in file contradicting header");
           }
           if (detail::if_true_<sym>()) {
               if (nnz > 2*m_) {
                   free();
                   throw Error("Header wants more non-zeros than found");
               }
           } else if (detail::if_true_<sl>()) {
               if (nnz > m_) {
                   free();
                   throw Error("Header wants more non-zeros than read");
               }
           } else {
               if (nnz != m_) {
                   free();
                   throw Error("Header contradicts number of read non-zeros");
               }
           }
   
           if (nrows_ > ncols_) n_ = nrows_;
           else n_ = ncols_;
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::read_el_(FileReader& r) {
           // Get the number of threads
           omp_set_dynamic(0);
           size_t num_threads = 0;
           #pragma omp parallel shared(num_threads)
           {
               #pragma omp single
               {
                   num_threads = omp_get_num_threads();
               }
           }
   
           // This takes two passes:
           // first, count the number of newlines to determine how to
           // allocate storage
           // second, copy over the values appropriately
   
           std::vector<size_t> nl_offsets(num_threads);
   
           L max_row = 0;
           L max_col = 0;
           #pragma omp parallel reduction(max : max_row) \
                   reduction(max : max_col)
           {
               size_t tid = omp_get_thread_num();
   
               // Find our offsets in the file
               size_t size = r.size();
               size_t tid_start_i = (tid*size)/num_threads;
               size_t tid_end_i = ((tid+1)*size)/num_threads;
               FileReader rs = r + tid_start_i;
               FileReader re = r + tid_end_i;
   
               // Now, move to the appropriate starting point to move off of
               // overlapping entries
               re.move_to_eol();
               re.move_to_next_int();
               if (tid != 0) {
                   rs.move_to_eol();
                   rs.move_to_next_int();
               } else
                   rs.move_to_first_int();
   
               // Set our file reader to end either at the full end or at
               // the thread id local end
               rs.smaller_end(re);
   
               // Pass 1
               // Iterate through, counting the number of newlines
               FileReader rs_p1 = rs;
               L max_unused;
               size_t tid_nls = 0;
               while (rs_p1.good()) {
                   read_coord_entry_<true>(tid_nls, rs_p1, max_unused, max_unused);
               }
   
               nl_offsets[tid] = tid_nls;
   
               // Compute a prefix sum on the newline offsets
               #pragma omp barrier
               #pragma omp single
               {
                   size_t sum_nl = 0;
                   for (size_t tid = 0; tid < num_threads; ++tid) {
                       sum_nl += nl_offsets[tid];
                       nl_offsets[tid] = sum_nl;
                   }
   
                   // Now, allocate the space appropriately
                   m_ = nl_offsets[num_threads-1];
                   allocate_();
               }
               #pragma omp barrier
   
               // Pass 2
               // Iterate through again, but now copying out the integers
               FileReader rs_p2 = rs;
               size_t coord_pos = 0;
               if (tid > 0)
                   coord_pos = nl_offsets[tid-1];
   
               while (rs_p2.good()) {
                   read_coord_entry_<false>(coord_pos, rs_p2, max_row, max_col);
               }
           }
   
           // Set the number of labels in the matrix represented by the COO
           nrows_ = max_row + 1;
           ncols_ = max_col + 1;
           if (nrows_ > ncols_) n_ = nrows_;
           else n_ = ncols_;
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::save(std::string fn) {
           // Before creating the file, we need to find the size
           size_t out_size = 0;
           std::string cfh { coo_file_header };
           out_size += cfh.size();
           // Find the template sizes
           out_size += sizeof(uint8_t)*2;
           // Find the size of the number of rows/etc.
           out_size += sizeof(L)*3+sizeof(O);
           // Finally, find the actual COO sizes
           out_size += sizeof(L)*m_*2;
           size_t w_size = detail::weight_size_<wgt, W, O>(m_);
           out_size += w_size;
   
           // Create the output file
           WFile w {fn, out_size};
   
           // Output the PIGO COO file header
           w.write(cfh);
   
           // Output the template sizes
           uint8_t L_size = sizeof(L);
           uint8_t O_size = sizeof(O);
           w.write(L_size);
           w.write(O_size);
   
           // Output the sizes and data
           w.write(nrows_);
           w.write(ncols_);
           w.write(n_);
           w.write(m_);
   
           // Output the data
           char* vx = detail::get_raw_data_<S>(x_);
           size_t vx_size = sizeof(L)*m_;
           w.parallel_write(vx, vx_size);
   
           char* vy = detail::get_raw_data_<S>(y_);
           size_t vy_size = sizeof(L)*m_;
           w.parallel_write(vy, vy_size);
   
           if (w_size > 0) {
               char* vw = detail::get_raw_data_<WS>(w_);
               w.parallel_write(vw, w_size);
           }
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::read_bin_(File& f) {
           // Read and confirm the header
           f.read(coo_file_header);
   
           // Confirm the sizes
           uint8_t L_size, O_size;
           L_size = f.read<uint8_t>();
           O_size = f.read<uint8_t>();
   
           if (L_size != sizeof(L)) throw Error("Invalid COO template parameters to match binary");
           if (O_size != sizeof(O)) throw Error("Invalid COO template parameters to match binary");
   
           // Read the sizes
           nrows_ = f.read<L>();
           ncols_ = f.read<L>();
           n_ = f.read<L>();
           m_ = f.read<O>();
   
           // Allocate space
           allocate_();
   
           // Read out the vectors
           char* vx = detail::get_raw_data_<S>(x_);
           size_t vx_size = sizeof(L)*m_;
           f.parallel_read(vx, vx_size);
   
           char* vy = detail::get_raw_data_<S>(y_);
           size_t vy_size = sizeof(L)*m_;
           f.parallel_read(vy, vy_size);
   
           size_t w_size = detail::weight_size_<wgt, W, O>(m_);
           if (w_size > 0) {
               char* vw = detail::get_raw_data_<WS>(w_);
               f.parallel_read(vw, w_size);
           }
       }
   
       template<class L, class O, class S, bool sym, bool ut, bool sl, bool wgt, class W, class WS>
       void COO<L,O,S,sym,ut,sl,wgt,W,WS>::write(std::string fn) {
           // Writing occurs in two passes
           // First, each thread will simulate writing and compute how the
           // space taken
           // After the first pass, the output file is allocated
           // Second, each thread actually writes
   
           // Get the number of threads
           omp_set_dynamic(0);
           size_t num_threads = 0;
           #pragma omp parallel shared(num_threads)
           {
               #pragma omp single
               {
                   num_threads = omp_get_num_threads();
               }
           }
   
           std::vector<size_t> pos_offsets(num_threads+1);
           std::shared_ptr<File> f;
           #pragma omp parallel shared(f) shared(pos_offsets)
           {
               size_t tid = omp_get_thread_num();
               size_t my_size = 0;
   
               #pragma omp for
               for (O e = 0; e < m_; ++e) {
                   auto x = detail::get_value_<S, L>(x_, e);
                   my_size += write_size(x);
   
                   // Account for the separating space
                   my_size += 1;
   
                   auto y = detail::get_value_<S, L>(y_, e);
                   my_size += write_size(y);
   
                   if (detail::if_true_<wgt>()) {
                       // Account for the separating space
                       my_size += 1;
   
                       auto w = detail::get_value_<WS, W>(w_, e);
                       my_size += write_size(w);
                   }
                   // Account for the file newline
                   my_size += 1;
               }
   
               pos_offsets[tid+1] = my_size;
               #pragma omp barrier
   
               #pragma omp single
               {
                   // Compute the total size and perform a prefix sum
                   pos_offsets[0] = 0;
                   for (size_t thread = 1; thread <= num_threads; ++thread)
                       pos_offsets[thread] = pos_offsets[thread-1] + pos_offsets[thread];
   
                   // Allocate the file
                   f = std::make_shared<File>(fn, WRITE, pos_offsets[num_threads]);
               }
   
               #pragma omp barrier
   
               FilePos my_fp = f->fp()+pos_offsets[tid];
   
               // Perform the second pass, actually writing out to the file
               #pragma omp for
               for (O e = 0; e < m_; ++e) {
                   auto x = detail::get_value_<S, L>(x_, e);
                   write_ascii(my_fp, x);
                   pigo::write(my_fp, ' ');
                   auto y = detail::get_value_<S, L>(y_, e);
                   write_ascii(my_fp, y);
                   if (detail::if_true_<wgt>()) {
                       pigo::write(my_fp, ' ');
                       auto w = detail::get_value_<WS, W>(w_, e);
                       write_ascii(my_fp, w);
                   }
                   pigo::write(my_fp, '\n');
               }
           }
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       CSR<L,O,LS,OS,wgt,W,WS>::CSR(std::string fn) : CSR(fn, AUTO) { }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       CSR<L,O,LS,OS,wgt,W,WS>::CSR(std::string fn, FileType ft) {
           // Open the file for reading
           ROFile f {fn};
           read_(f, ft);
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       CSR<L,O,LS,OS,wgt,W,WS>::CSR(File& f, FileType ft) {
           read_(f, ft);
       }
   
       namespace detail {
           template<bool wgt>
           struct fail_if_weighted_i_ { static void op_() {} };
           template<>
           struct fail_if_weighted_i_<true> {
               static void op_() {
                   throw NotYetImplemented("Not yet implemented for weights.");
               }
           };
           template<bool wgt>
           void fail_if_weighted() {
               fail_if_weighted_i_<wgt>::op_();
           }
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::read_(File& f, FileType ft) {
           FileType ft_used = ft;
           // If the file type is AUTO, then try to detect it
           if (ft_used == AUTO) {
               ft_used = f.guess_file_type();
           }
   
           if (ft_used == MATRIX_MARKET || ft_used == EDGE_LIST ||
                   ft_used == PIGO_COO_BIN) {
               // First build a COO, then load here
               COO<L,O,L*, false, false, false, wgt, W, WS> coo { f, ft_used };
               convert_coo_(coo);
               coo.free();
           } else if (ft_used == PIGO_CSR_BIN) {
               read_bin_(f);
           } else if (ft_used == GRAPH) {
               detail::fail_if_weighted<wgt>();
               FileReader r = f.reader();
               read_graph_(r);
           } else
               throw NotYetImplemented("This file type is not yet supported");
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::allocate_() {
           detail::allocate_mem_<LS>(endpoints_, m_);
           detail::allocate_mem_<WS,wgt>(weights_, m_);
           detail::allocate_mem_<OS>(offsets_, n_+1);
       }
       namespace detail {
           template<bool wgt, class W, class WS, class COOW, class COOWS, class O>
           struct copy_weight_i_ {
               static void op_(WS&, O, COOWS&, O) {}
           };
   
           template<class W, class WS, class COOW, class COOWS, class O>
           struct copy_weight_i_<true, W, WS, COOW, COOWS, O> {
               static void op_(WS& w, O p, COOWS& coow, O coop) {
                   COOW val = get_value_<COOWS, COOW>(coow, coop);
                   set_value_<WS, W>(w, p, (W)val);
               }
           };
   
           template<bool wgt, class W, class WS, class COOW, class COOWS, class O>
           void copy_weight(WS& w, O offset, COOWS& coo_w, O coo_pos) {
               copy_weight_i_<wgt, W, WS, COOW, COOWS, O>::op_(w, offset,
                       coo_w, coo_pos);
           }
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W,
           class WS> template<class COOL, class COOO, class COOStorage, bool
               COOsym, bool COOut, bool COOsl, class COOW, class
               COOWS>
       CSR<L,O,LS,OS,wgt,W,WS>::CSR(COO<COOL,COOO,COOStorage,COOsym,
               COOut,COOsl,wgt,COOW,COOWS>
               &coo) {
           convert_coo_(coo);
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W,
           class WS> template<class COOL, class COOO, class COOStorage,
           bool COOsym, bool COOut, bool COOsl,
           class COOW, class COOWS>
       void CSR<L,O,LS,OS,wgt,W,WS>::convert_coo_(COO<
               COOL,COOO,COOStorage,COOsym,COOut,COOsl,wgt,COOW,COOWS>&
               coo) {
           // Set the sizes first
           n_ = coo.n();
           m_ = coo.m();
           nrows_ = coo.nrows();
           ncols_ = coo.ncols();
   
           // Allocate the offsets and endpoints
           allocate_();
   
           // This is a multi pass algorithm.
           // First, we need to count each vertex's degree and allocate the
           // space appropriately.
           // Next, we go through the degrees and change them to offsets
           // Finally, we need to go through the COO and copy memory
   
           // Get the number of threads
           omp_set_dynamic(0);
           size_t num_threads = 0;
           #pragma omp parallel shared(num_threads)
           {
               #pragma omp single
               {
                   num_threads = omp_get_num_threads();
               }
           }
   
           // Temporarily keep track of the degree for each label (this can
           // easily be computed later)
           O* label_degs = new O[n_];
   
           // Keep track of the starting offsets for each thread
           O* start_offsets = new O[num_threads];
   
           // Each thread will compute the degrees for each label on its own.
           // This is then used to reduce them all
           O* all_degs = new O[n_];
           #pragma omp parallel shared(all_degs) shared(label_degs) shared(start_offsets)
           {
               size_t tid = omp_get_thread_num();
   
               L v_start = (tid*n_)/num_threads;
               L v_end = ((tid+1)*n_)/num_threads;
               // We need to initialize degrees to count for zero-degree
               // vertices
               #pragma omp for
               for (L v = 0; v < n_; ++v)
                   all_degs[v] = 0;
   
               auto coo_x = coo.x();
               auto coo_y = coo.y();
               auto coo_w = coo.w();
   
               #pragma omp for
               for (O x_id = 0; x_id < m_; ++x_id) {
                   size_t deg_inc = detail::get_value_<COOStorage, L>(coo_x, x_id);
                   #pragma omp atomic
                   ++all_degs[deg_inc];
               }
   
               // Reduce the degree vectors
               #pragma omp barrier
               // Now all degs (via all_degs) have been computed
   
               O my_degs = 0;
               for (L c = v_start; c < v_end; ++c) {
                   O this_deg = all_degs[c];
                   label_degs[c] = this_deg;
                   my_degs += this_deg;
               }
   
               // Save our local degree count to do a prefix sum on
               start_offsets[tid] = my_degs;
   
               // Get a memory allocation
               // Do a prefix sum to keep everything compact by row
               #pragma omp barrier
               #pragma omp single
               {
                   O total_degs = 0;
                   for (size_t cur_tid = 0; cur_tid < num_threads; ++cur_tid) {
                       total_degs += start_offsets[cur_tid];
                       start_offsets[cur_tid] = total_degs;
                   }
               }
               #pragma omp barrier
   
               // Get the starting offset
               // The prefix sum array is off by one, so the start is at zero
               O cur_offset = 0;
               if (tid > 0)
                   cur_offset = start_offsets[tid-1];
   
               // Now, assign the offsets to each label
               for (L c = v_start; c < v_end; ++c) {
                   detail::set_value_(offsets_, c, cur_offset);
                   cur_offset += label_degs[c];
               }
               #pragma omp single
               {
                   // Patch the last offset to the end, making for easier
                   // degree computation and iteration
                   detail::set_value_(offsets_, n_, m_);
               }
   
               #pragma omp barrier
               // Now, all offsets_ have been assigned
   
               // Here, we use the degrees computed earlier and treat them
               // instead as the remaining vertices, showing the current copy
               // position
   
               // Finally, copy over the actual endpoints
               #pragma omp for
               for (O coo_pos = 0; coo_pos < m_; ++coo_pos) {
                   L src = detail::get_value_<COOStorage, L>(coo_x, coo_pos);
                   L dst = detail::get_value_<COOStorage, L>(coo_y, coo_pos);
   
                   O this_offset_pos;
                   #pragma omp atomic capture
                   {
                       this_offset_pos = label_degs[src];
                       label_degs[src]--;
                   }
                   O this_offset = detail::get_value_<OS, O>(offsets_, src+1) - this_offset_pos;
                   detail::set_value_(endpoints_, this_offset, dst);
                   detail::copy_weight<wgt,W,WS,COOW,COOWS>(weights_, this_offset, coo_w, coo_pos);
               }
   
           }
   
           delete [] label_degs;
           delete [] start_offsets;
           delete [] all_degs;
   
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::read_graph_(FileReader &r) {
           // Get the number of threads
           omp_set_dynamic(0);
           size_t num_threads = 0;
           #pragma omp parallel shared(num_threads)
           {
               #pragma omp single
               {
                   num_threads = omp_get_num_threads();
               }
           }
   
           // We have a header containing the number of vertices and edges.
           // This is used to verify and check correctness
           r.move_to_first_int();
           L read_n = r.read_int<L>();
           r.move_to_next_int();
           O read_m = r.read_int<O>();
           r.move_to_eol();
           r.move_to_next_int();
   
           // This takes two passes:
           // first, count the number of newlines and integers to allocate
           // storage
           // second, copy over the values appropriately
   
           std::vector<size_t> nl_offsets(num_threads);
           std::vector<size_t> int_offsets(num_threads);
           std::vector<L> max_labels(num_threads);
           std::vector<bool> have_zeros(num_threads, false);
           bool have_zero;
           #pragma omp parallel shared(have_zero) shared(have_zeros)
           {
               size_t tid = omp_get_thread_num();
   
               // Find our offsets in the file
               size_t size = r.size();
               size_t tid_start_i = (tid*size)/num_threads;
               size_t tid_end_i = ((tid+1)*size)/num_threads;
               FileReader rs = r + tid_start_i;
               FileReader re = r + tid_end_i;
   
               // Now, move to the appropriate starting point
               re.move_to_next_int();
               if (tid != 0) {
                   rs.move_to_next_int();
               } else
                   rs.move_to_first_int();
   
               // Set our file reader to end either at the full end or at
               // the thread id local end
               rs.smaller_end(re);
   
               // Now, perform the first pass and count
               FileReader rs_p1 = rs;
               size_t tid_nls = 0;
               size_t tid_ints = 0;
               bool my_have_zero = false;
               while (rs_p1.good()) {
                   if (rs_p1.at_nl_or_eol())
                       ++tid_nls;
                   else
                       ++tid_ints;
                   // Determine if this is a 0
                   if (rs_p1.at_zero() && !my_have_zero)
                       my_have_zero = true;
   
                   rs_p1.move_to_next_int_or_nl();
               }
               if (my_have_zero) {
                   have_zeros[tid] = true;
               }
   
               #pragma omp barrier
               #pragma omp single
               {
                   bool found_zero = false;
                   for (size_t tid = 0; tid < num_threads; ++tid) {
                       if (have_zeros[tid]) {
                           found_zero = true;
                           break;
                       }
                   }
                   if (found_zero) have_zero = true;
                   else have_zero = false;
               }
               #pragma omp barrier
   
               nl_offsets[tid] = tid_nls;
               int_offsets[tid] = tid_ints;
   
               // Compute a prefix sum on the offsets
               #pragma omp barrier
               #pragma omp single
               {
                   size_t sum_nl = (have_zero) ? 0 : 1;
                   size_t sum_ints = 0;
                   for (size_t tid = 0; tid < num_threads; ++tid) {
                       sum_nl += nl_offsets[tid];
                       nl_offsets[tid] = sum_nl;
   
                       sum_ints += int_offsets[tid];
                       int_offsets[tid] = sum_ints;
                   }
   
                   // Now, allocate the space appropriately
                   m_ = int_offsets[num_threads-1];
                   n_ = nl_offsets[num_threads-1];
                   nrows_ = n_;
                   allocate_();
                   detail::set_value_(offsets_, 0, 0);
                   if (!have_zero)
                       detail::set_value_(offsets_, 1, 0);
                   detail::set_value_(offsets_, n_, m_);
               }
               #pragma omp barrier
   
               // Pass 2: iterate through again, but now copy out the values
               // to the appropriate position in the endpoints / offsets
               L my_max = 0;
               FileReader rs_p2 = rs;
               O endpoint_pos = 0;
               L offset_pos = 0;
               if (tid > 0) {
                   offset_pos = nl_offsets[tid-1];
                   endpoint_pos = int_offsets[tid-1];
               } else if (!have_zero)
                   offset_pos = 1;
   
               while (rs_p2.good()) {
                   // Ignore any trailing data in the file
                   if (offset_pos >= n_) break;
   
                   // Copy and set the endpoint
                   if (rs_p2.at_nl_or_eol()) {
                       // Set the offset to the current endpoint position
                       detail::set_value_(offsets_, ++offset_pos, endpoint_pos);
                       rs_p2.move_to_next_int_or_nl();
                   } else {
                       // Set the actual value
                       L endpoint = rs_p2.read_int<L>();
                       if (endpoint > my_max)
                           my_max = endpoint;
                       detail::set_value_(endpoints_, endpoint_pos++, endpoint);
                       if (!rs_p2.at_nl_or_eol())
                           rs_p2.move_to_next_int_or_nl();
                   }
               }
               max_labels[tid] = my_max;
           }
   
           if (m_ == 2*read_m) {}
           else if (m_ != read_m) throw Error("Mismatch in CSR nonzeros and header");
           if (n_ < read_n) throw Error("Mismatch in CSR newlines and header");
           else n_ = read_n;
   
           L col_max = max_labels[0];
           for (size_t thread = 1; thread < num_threads; ++thread) {
               if (max_labels[thread] > col_max)
                   col_max = max_labels[thread];
           }
           ncols_ = col_max+1;
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       size_t CSR<L,O,LS,OS,wgt,W,WS>::save_size() const {
           size_t out_size = 0;
           std::string cfh { csr_file_header };
           out_size += cfh.size();
           // Find the template sizes
           out_size += sizeof(uint8_t)*2;
           // Find the size of the size of the CSR
           out_size += sizeof(L)*3+sizeof(O);
           // Finally, find the actual CSR size
           size_t voff_size = sizeof(O)*(n_+1);
           size_t vend_size = sizeof(L)*m_;
           size_t w_size = detail::weight_size_<wgt, W, O>(m_);
           out_size += voff_size + vend_size + w_size;
   
           return out_size;
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::save(std::string fn) {
           // Before creating the file, we need to find the size
           size_t out_size = save_size();
   
           // Create the output file
           WFile w {fn, out_size};
   
           // Now, perform the actual save
           save(w);
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::save(File& w) {
           // Output the file header
           std::string cfh { csr_file_header };
           w.write(cfh);
   
           // Output the template sizes
           uint8_t L_size = sizeof(L);
           uint8_t O_size = sizeof(O);
           w.write(L_size);
           w.write(O_size);
   
           // Output the sizes and data
           w.write(n_);
           w.write(m_);
           w.write(nrows_);
           w.write(ncols_);
   
           size_t voff_size = sizeof(O)*(n_+1);
           size_t vend_size = sizeof(L)*m_;
           size_t w_size = detail::weight_size_<wgt, W, O>(m_);
   
           // Output the data
           char* voff = detail::get_raw_data_<OS>(offsets_);
           w.parallel_write(voff, voff_size);
   
           char* vend = detail::get_raw_data_<LS>(endpoints_);
           w.parallel_write(vend, vend_size);
   
           if (w_size > 0) {
               char* wend = detail::get_raw_data_<WS>(weights_);
               w.parallel_write(wend, w_size);
           }
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::read_bin_(File& f) {
           // Read and confirm the header
           f.read(csr_file_header);
   
           // Confirm the sizes
           uint8_t L_size, O_size;
           L_size = f.read<uint8_t>();
           O_size = f.read<uint8_t>();
   
           if (L_size != sizeof(L)) throw Error("Invalid CSR template parameters to match binary");
           if (O_size != sizeof(O)) throw Error("Invalid CSR template parameters to match binary");
   
           // Read the sizes
           n_ = f.read<L>();
           m_ = f.read<O>();
           nrows_ = f.read<L>();
           ncols_ = f.read<L>();
   
           // Allocate space
           allocate_();
   
           size_t voff_size = sizeof(O)*(n_+1);
           size_t vend_size = sizeof(L)*m_;
   
           // Read out the vectors
           char* voff = detail::get_raw_data_<OS>(offsets_);
           f.parallel_read(voff, voff_size);
   
           char* vend = detail::get_raw_data_<LS>(endpoints_);
           f.parallel_read(vend, vend_size);
   
           size_t w_size = detail::weight_size_<wgt, W, O>(m_);
           if (w_size > 0) {
               char* wend = detail::get_raw_data_<WS>(weights_);
               f.parallel_read(wend, w_size);
           }
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       void CSR<L,O,LS,OS,wgt,W,WS>::sort() {
           #pragma omp parallel for schedule(dynamic, 10240)
           for (L v = 0; v < n_; ++v) {
               // Get the start and end range
               O start = detail::get_value_<OS, O>(offsets_, v);
               O end = detail::get_value_<OS, O>(offsets_, v+1);
   
               // Sort the range from the start to the end
               if (detail::if_true_<wgt>()) {
                   // This should be improved, e.g., without replicating
                   // everything. For now, make a joint array, sort that, and
                   // then pull out the resulting data
                   std::vector<std::pair<L, W>> vec;
                   vec.reserve(end-start);
                   for (O cur = start; cur < end; ++cur) {
                       L l = detail::get_value_<LS, L>(endpoints_, cur);
                       W w = detail::get_value_<WS, W>(weights_, cur);
                       std::pair<L, W> val = {l, w};
                       vec.emplace_back(val);
                   }
                   std::sort(vec.begin(), vec.end());
                   O cur = start;
                   for (auto& pair : vec) {
                       L l = std::get<0>(pair);
                       W w = std::get<1>(pair);
                       detail::set_value_(endpoints_, cur, l);
                       detail::set_value_(weights_, cur, w);
                       ++cur;
                   }
               } else {
                   L* endpoints = (L*)detail::get_raw_data_(endpoints_);
   
                   L* range_start = endpoints+start;
                   L* range_end = endpoints+end;
   
                   std::sort(range_start, range_end);
               }
           }
       }
   
       template<class L, class O, class LS, class OS, bool wgt, class W, class WS>
       template<class nL, class nO, class nLS, class nOS, bool nw, class nW, class nWS>
       CSR<nL, nO, nLS, nOS, nw, nW, nWS> CSR<L,O,LS,OS,wgt,W,WS>::new_csr_without_dups() {
           // First, sort ourselves
           sort();
   
           // Next, count the degrees for each vertex, excluding duplicates
           std::shared_ptr<L> degs_storage;
           detail::allocate_mem_(degs_storage, n_);
           L* degs = degs_storage.get();
   
           nO new_m = 0;
   
           #pragma omp parallel for schedule(dynamic, 10240) shared(degs) reduction(+ : new_m)
           for (L v = 0; v < n_; ++v) {
               O start = detail::get_value_<OS, O>(offsets_, v);
               O end = detail::get_value_<OS, O>(offsets_, v+1);
               if (end-start == 0) {
                   degs[v] = 0;
                   continue;
               }
   
               L prev_val = detail::get_value_<LS, L>(endpoints_, start++);
               L new_deg = 1;
   
               while (start != end) {
                   L cur_val = detail::get_value_<LS, L>(endpoints_, start++);
                   if (cur_val != prev_val) {
                       prev_val = cur_val;
                       ++new_deg;
                   }
               }
   
               degs[v] = new_deg;
               new_m += new_deg;
           }
   
           // Allocate the new CSR
           CSR<nL, nO, nLS, nOS, nw, nW, nWS> ret { (nL)n_, new_m, (nL)nrows_, (nL)ncols_ };
   
           auto& new_endpoints = ret.endpoints();
           auto& new_offsets = ret.offsets();
           auto& new_weights = ret.weights();
   
           // Set the offsets by doing a prefix sum on the degrees
   
           // Get the number of threads
           omp_set_dynamic(0);
           size_t num_threads = 0;
           #pragma omp parallel shared(num_threads)
           {
               #pragma omp single
               {
                   num_threads = omp_get_num_threads();
               }
           }
           // Keep track of the starting offsets for each thread
           std::shared_ptr<O> so_storage;
           detail::allocate_mem_(so_storage, num_threads);
           O* start_offsets = so_storage.get();
   
           #pragma omp parallel shared(start_offsets)
           {
               size_t tid = omp_get_thread_num();
   
               L v_start = (tid*n_)/num_threads;
               L v_end = ((tid+1)*n_)/num_threads;
   
               O my_degs = 0;
               for (L c = v_start; c < v_end; ++c) {
                   // FIXME get the degs
                   O this_deg = degs[c];
                   my_degs += this_deg;
               }
   
               // Save our local degree count to do a prefix sum on
               start_offsets[tid] = my_degs;
   
               #pragma omp barrier
               #pragma omp single
               {
                   O total_degs = 0;
                   for (size_t cur_tid = 0; cur_tid < num_threads; ++cur_tid) {
                       total_degs += start_offsets[cur_tid];
                       start_offsets[cur_tid] = total_degs;
                   }
               }
               #pragma omp barrier
   
               // Get the starting offset
               // The prefix sum array is off by one, so the start is at zero
               O cur_offset = 0;
               if (tid > 0)
                   cur_offset = start_offsets[tid-1];
   
               // Now, assign the offsets to each label
               for (L c = v_start; c < v_end; ++c) {
                   detail::set_value_(new_offsets, c, cur_offset);
                   cur_offset += degs[c];
               }
               #pragma omp single
               {
                   // Patch the last offset to the end, making for easier
                   // degree computation and iteration
                   detail::set_value_(new_offsets, (nL)n_, new_m);
               }
   
               // Now, all new offsets have been assigned
           }
   
           // Repeat going through the edges, copying out the endpoints
           #pragma omp parallel for schedule(dynamic, 10240)
           for (L v = 0; v < n_; ++v) {
               O o_start = detail::get_value_<OS, O>(offsets_, v);
               O o_end = detail::get_value_<OS, O>(offsets_, v+1);
               if (o_end-o_start == 0) continue;
   
               nO n_cur = detail::get_value_<nOS, nO>(new_offsets, (nL)v);
   
               L prev_val = detail::get_value_<LS, L>(endpoints_, o_start++);
               detail::set_value_(new_endpoints, n_cur++, prev_val);
               if (detail::if_true_<nw>()) {
                   W w = detail::get_value_<WS, W>(weights_, o_start-1);
                   detail::set_value_(new_weights, n_cur-1, (nW)w);
               }
   
               while (o_start != o_end) {
                   L cur_val = detail::get_value_<LS, L>(endpoints_, o_start++);
                   if (prev_val != cur_val) {
                       prev_val = cur_val;
                       detail::set_value_(new_endpoints, n_cur++, (nL)prev_val);
                       if (detail::if_true_<nw>()) {
                           W w = detail::get_value_<WS, W>(weights_, o_start-1);
                           detail::set_value_(new_weights, n_cur-1, (nW)w);
                       }
                   }
               }
           }
   
           return ret;
       }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       DiGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::DiGraph(std::string fn) :
           DiGraph(fn, AUTO) { }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       DiGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::DiGraph(std::string fn, FileType ft) {
           ROFile f {fn};
           read_(f, ft);
       }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       DiGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::DiGraph(File& f, FileType ft) {
           read_(f, ft);
       }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       void DiGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::read_(File& f, FileType ft) {
           FileType ft_used = ft;
           // If the file type is AUTO, then try to detect it
           if (ft_used == AUTO) {
               ft_used = f.guess_file_type();
           }
           if (ft_used == PIGO_DIGRAPH_BIN) {
               // First load the in, then the out
               // Read out the header
               f.read(digraph_file_header);
               in_ = BaseGraph<
                           vertex_t,
                           edge_ctr_t,
                           edge_storage,
                           edge_ctr_storage,
                           weighted,
                           Weight,
                           WeightStorage
                       > { f, AUTO };
               out_ = BaseGraph<
                           vertex_t,
                           edge_ctr_t,
                           edge_storage,
                           edge_ctr_storage,
                           weighted,
                           Weight,
                           WeightStorage
                       > { f, AUTO };
           } else {
               // Build a COO, then load ourselves from it
               COO<
                       vertex_t, edge_ctr_t, edge_storage,
                       false, false, false,
                       weighted, Weight, WeightStorage
                   > coo { f, ft };
               from_coo_(coo);
               coo.free();
           }
       }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       void DiGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::save(std::string fn) {
           // Find the total size to save
           size_t out_size = 0;
   
           std::string dfh { digraph_file_header };
           out_size += dfh.size();
   
           out_size += in_.save_size();
           out_size += out_.save_size();
   
           // Now, create the file and output everything
           WFile w {fn, out_size};
   
           w.write(dfh);
   
           in_.save(w);
           out_.save(w);
       }
   
       template<class V, class O, class S>
       V& EdgeItT<V,O,S>::operator*() { return detail::get_value_<S, V&>(s, pos); }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       edge_ctr_t BaseGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::neighbor_start(vertex_t v) {
           return detail::get_value_<edge_ctr_storage, edge_ctr_t>(this->offsets_, v);
       }
   
       template<class vertex_t, class edge_ctr_t, class edge_storage, class edge_ctr_storage, bool weighted, class Weight, class WeightStorage>
       edge_ctr_t BaseGraph<vertex_t, edge_ctr_t, edge_storage, edge_ctr_storage, weighted, Weight, WeightStorage>::neighbor_end(vertex_t v) {
           return detail::get_value_<edge_ctr_storage, edge_ctr_t>(this->offsets_, v+1);
       }
   
   }
   
   #endif /* PIGO_HPP */
